/*
 * generated by Xtext 2.40.0.M3
 */
package eu.extremexp.ssfhai.dsl.serializer;

import com.google.inject.Inject;
import eu.extremexp.ssfhai.dsl.mLDSL.Data;
import eu.extremexp.ssfhai.dsl.mLDSL.FLOAT;
import eu.extremexp.ssfhai.dsl.mLDSL.Flow;
import eu.extremexp.ssfhai.dsl.mLDSL.Forward;
import eu.extremexp.ssfhai.dsl.mLDSL.Layer;
import eu.extremexp.ssfhai.dsl.mLDSL.MLDSLPackage;
import eu.extremexp.ssfhai.dsl.mLDSL.Model;
import eu.extremexp.ssfhai.dsl.mLDSL.Network;
import eu.extremexp.ssfhai.dsl.mLDSL.Option;
import eu.extremexp.ssfhai.dsl.mLDSL.Param;
import eu.extremexp.ssfhai.dsl.mLDSL.ParamValue;
import eu.extremexp.ssfhai.dsl.mLDSL.Task;
import eu.extremexp.ssfhai.dsl.mLDSL.Workflow;
import eu.extremexp.ssfhai.dsl.services.MLDSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MLDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MLDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MLDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MLDSLPackage.DATA:
				sequence_Data(context, (Data) semanticObject); 
				return; 
			case MLDSLPackage.FLOAT:
				sequence_FLOAT(context, (FLOAT) semanticObject); 
				return; 
			case MLDSLPackage.FLOW:
				sequence_Flow(context, (Flow) semanticObject); 
				return; 
			case MLDSLPackage.FORWARD:
				sequence_Forward(context, (Forward) semanticObject); 
				return; 
			case MLDSLPackage.LAYER:
				sequence_Layer(context, (Layer) semanticObject); 
				return; 
			case MLDSLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MLDSLPackage.NETWORK:
				sequence_Network(context, (Network) semanticObject); 
				return; 
			case MLDSLPackage.OPTION:
				sequence_Option(context, (Option) semanticObject); 
				return; 
			case MLDSLPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case MLDSLPackage.PARAM_VALUE:
				sequence_ParamValue(context, (ParamValue) semanticObject); 
				return; 
			case MLDSLPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case MLDSLPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Data returns Data
	 *     WorkflowEntinty returns Data
	 *
	 * Constraint:
	 *     ((name=ID path=STRING) | features=STRING | target=STRING)+
	 * </pre>
	 */
	protected void sequence_Data(ISerializationContext context, Data semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FLOAT returns FLOAT
	 *
	 * Constraint:
	 *     (dec=INT per=INT)
	 * </pre>
	 */
	protected void sequence_FLOAT(ISerializationContext context, FLOAT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MLDSLPackage.Literals.FLOAT__DEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MLDSLPackage.Literals.FLOAT__DEC));
			if (transientValues.isValueTransient(semanticObject, MLDSLPackage.Literals.FLOAT__PER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MLDSLPackage.Literals.FLOAT__PER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFLOATAccess().getDecINTTerminalRuleCall_0_0(), semanticObject.getDec());
		feeder.accept(grammarAccess.getFLOATAccess().getPerINTTerminalRuleCall_2_0(), semanticObject.getPer());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Flow returns Flow
	 *
	 * Constraint:
	 *     (sequenceStart=[Task|ID] sequence+=[Task|ID]+)
	 * </pre>
	 */
	protected void sequence_Flow(ISerializationContext context, Flow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Forward returns Forward
	 *
	 * Constraint:
	 *     (sequenceStart=[Layer|ID] sequence+=[Layer|ID]+)
	 * </pre>
	 */
	protected void sequence_Forward(ISerializationContext context, Forward semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Layer returns Layer
	 *
	 * Constraint:
	 *     (name=ID (options+=Option options+=Option*)?)
	 * </pre>
	 */
	protected void sequence_Layer(ISerializationContext context, Layer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID workflows+=Workflow*)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowEntinty returns Network
	 *     Network returns Network
	 *
	 * Constraint:
	 *     (name=ID (layers+=Layer | forwards+=Forward)*)
	 * </pre>
	 */
	protected void sequence_Network(ISerializationContext context, Network semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns Option
	 *
	 * Constraint:
	 *     (type=LayerType | inputSize=INT | outputSize=INT | dropeoutRate=FLOAT)
	 * </pre>
	 */
	protected void sequence_Option(ISerializationContext context, Option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParamValue returns ParamValue
	 *
	 * Constraint:
	 *     (intValue=INT | floatValue=FLOAT | stringValue=STRING)
	 * </pre>
	 */
	protected void sequence_ParamValue(ISerializationContext context, ParamValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     ((name=ID paramValue=ParamValue) | (name=ID entityValue=[WorkflowEntinty|ID]))
	 * </pre>
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Task returns Task
	 *     WorkflowEntinty returns Task
	 *
	 * Constraint:
	 *     (name=ID params+=Param*)
	 * </pre>
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (name=ID (tasks+=Task | flows+=Flow | data+=Data | networks+=Network)*)
	 * </pre>
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
